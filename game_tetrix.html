<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Responsive Snake HTML Game</title>
  <style>
    /* Reset and Base Styles */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden; /* Prevent page scrolling */
      background: #000;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    /* Title Container */
    .title-container {
      width: 100%;
      background-color: #000;
      color: #fff;
      text-align: center;
      padding: 10px 0;
      position: relative;
      z-index: 10;
    }

    .title-container h1 {
      font-size: 1.5rem;
    }

    /* Game Container */
    .game-container {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      flex-grow: 1;
      width: 100%;
      max-width: 100%;
      padding: 10px;
    }

    /* Canvas Styles */
    canvas {
      border: 2px solid #fff;
      background: #111;
      touch-action: none; /* Prevent browser default touch actions */
    }

    /* Score Display */
    .score-container {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      font-size: 1rem;
      z-index: 5;
    }

    .score-container .score,
    .score-container .high-score {
      margin: 5px 0;
    }

    /* Start Screen */
    .start-screen,
    .game-over {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      z-index: 20;
      width: 80%;
      max-width: 300px;
    }

    .start-screen h2,
    .game-over h2 {
      margin-bottom: 10px;
      font-size: 1.2rem;
    }

    .start-screen p,
    .game-over p {
      margin-bottom: 15px;
      font-size: 1rem;
    }

    .start-screen button,
    .game-over button {
      margin: 5px;
      padding: 10px 15px;
      font-size: 1rem;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      color: #fff;
      transition: background 0.3s;
    }

    .start-screen button {
      background-color: #007bff;
    }

    .start-screen button:hover {
      background-color: #0056b3;
    }

    .game-over button {
      background-color: #28a745;
    }

    .game-over button#resetHighScoreButton {
      background-color: #dc3545;
    }

    .game-over button:hover {
      opacity: 0.8;
    }

    /* Responsive Adjustments */
    @media (max-width: 600px) {
      .title-container h1 {
        font-size: 1.2rem;
      }

      .score-container {
        font-size: 0.9rem;
      }

      .start-screen,
      .game-over {
        width: 90%;
        max-width: 250px;
        padding: 15px;
      }

      .start-screen h2,
      .game-over h2 {
        font-size: 1.1rem;
      }

      .start-screen p,
      .game-over p {
        font-size: 0.9rem;
      }

      .start-screen button,
      .game-over button {
        padding: 8px 12px;
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <!-- Title Container -->
  <div class="title-container">
    <h1>Snake Game üêç</h1>
  </div>

  <!-- Game Container -->
  <div class="game-container">
    <canvas id="game"></canvas>
    <div class="score-container">
      <div class="score">Score: 0</div>
      <div class="high-score">High Score: 0</div>
    </div>
  </div>

  <!-- Start Screen -->
  <div class="start-screen" id="startScreen">
    <h2>Welcome to Snake Game!</h2>
    <p>Use arrow keys or swipe to control the snake.</p>
    <button id="startButton">Start Game</button>
  </div>

  <!-- Game Over Screen -->
  <div class="game-over" id="gameOverScreen" style="display: none;">
    <h2>Game Over</h2>
    <p>Your Score: <span id="finalScore">0</span></p>
    <p>High Score: <span id="finalHighScore">0</span></p>
    <button id="restartButton">Restart Game</button>
    <button id="resetHighScoreButton">Reset High Score</button>
  </div>

  <script>
    // 1. Initial Setup: Canvas, Context, and Grid Size
    const canvas = document.getElementById('game');
    const context = canvas.getContext('2d');
    let grid = 20; // Default grid size, will be dynamically adjusted
    let canvasWidth, canvasHeight;

    // Define grid sizes based on screen width
    const gridSizes = {
      small: 25,   // For screens <= 600px
      medium: 20,  // For screens between 601px and 900px
      large: 15    // For screens > 900px
    };

    // 2. Snake Object: Position, Velocity, and Body Cells
    const snake = {
      x: 0,
      y: 0,
      dx: 0, // Initial movement is stationary until game starts
      dy: 0,
      cells: [], // Snake's body cells (each cell occupies one grid space)
      maxCells: 4, // Initial length of the snake
      direction: 'right' // Current direction
    };

    // 3. Apple Object: Position
    const apple = {
      x: 0,
      y: 0
    };

    // 4. Score Tracking
    let score = 0;
    let highScore = localStorage.getItem('snakeHighScore') || 0;

    // 5. Helper Function: Random Integer in Range (for Apple Placement)
    function getRandomInt(min, max) {
      return Math.floor(Math.random() * (max - min)) + min;
    }

    // 6. Responsive Canvas Setup
    function resizeCanvas() {
      // Calculate available viewport size
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;

      // Calculate the height occupied by the title container and padding
      const titleHeight = document.querySelector('.title-container').offsetHeight;
      const padding = 20; // Additional padding

      // Determine the maximum square size that fits within the viewport
      const availableWidth = windowWidth - 20; // Account for padding/margins
      const availableHeight = windowHeight - titleHeight - padding;

      const size = Math.min(availableWidth, availableHeight) * 0.95; // 95% of the smaller dimension

      // Select grid size based on screen width
      if (windowWidth <= 600) {
        grid = gridSizes.small;
      } else if (windowWidth <= 900) {
        grid = gridSizes.medium;
      } else {
        grid = gridSizes.large;
      }

      // Calculate the number of cells that can fit
      const numCells = Math.floor(size / grid);

      // Adjust canvas size to fit the grid
      const finalSize = numCells * grid;

      canvas.width = finalSize;
      canvas.height = finalSize;
      canvasWidth = canvas.width;
      canvasHeight = canvas.height;

      // Update high score display
      updateScore();

      // Reset the game to apply new grid size
      resetGame();
    }

    // 7. Game Loop with Time-based Movement Control
    let lastTime = 0;
    const fps = 15;
    const interval = 1000 / fps;
    let animationFrameId;

    // Game loop function
    function loop(timestamp) {
      animationFrameId = requestAnimationFrame(loop);

      if (!lastTime) {
        lastTime = timestamp;
      }

      const elapsed = timestamp - lastTime;

      if (elapsed > interval) {
        lastTime = timestamp - (elapsed % interval);

        // Clear canvas
        context.clearRect(0, 0, canvasWidth, canvasHeight);

        // Move snake by its velocity
        snake.x += snake.dx;
        snake.y += snake.dy;

        // Wrap snake position horizontally on edge of screen
        if (snake.x < 0) {
          snake.x = canvasWidth - grid;
        } else if (snake.x >= canvasWidth) {
          snake.x = 0;
        }

        // Wrap snake position vertically on edge of screen
        if (snake.y < 0) {
          snake.y = canvasHeight - grid;
        } else if (snake.y >= canvasHeight) {
          snake.y = 0;
        }

        // Keep track of where snake has been
        snake.cells.unshift({x: snake.x, y: snake.y});

        // Remove cells as we move away from them
        if (snake.cells.length > snake.maxCells) {
          snake.cells.pop();
        }

        // Draw apple
        context.fillStyle = 'red';
        context.fillRect(apple.x, apple.y, grid - 2, grid - 2); // Increased size for visibility

        // Draw snake
        context.fillStyle = 'lime';
        snake.cells.forEach(function(cell, index) {
          context.fillRect(cell.x, cell.y, grid - 2, grid - 2); // Increased size for visibility

          // Check if snake ate the apple
          if (cell.x === apple.x && cell.y === apple.y) {
            snake.maxCells++;
            score++;
            updateScore();
            placeApple();
          }

          // Check for collision with the snake itself
          for (let i = index + 1; i < snake.cells.length; i++) {
            if (cell.x === snake.cells[i].x && cell.y === snake.cells[i].y) {
              endGame();
              return;
            }
          }
        });
      }
    }

    // 8. Keyboard Controls: Handle Direction Changes with Prevention of Reverse
    document.addEventListener('keydown', function(e) {
      const key = e.key;
      switch(key) {
        case 'ArrowLeft':
          if (snake.direction !== 'right') {
            snake.dx = -grid;
            snake.dy = 0;
            snake.direction = 'left';
          }
          break;
        case 'ArrowUp':
          if (snake.direction !== 'down') {
            snake.dy = -grid;
            snake.dx = 0;
            snake.direction = 'up';
          }
          break;
        case 'ArrowRight':
          if (snake.direction !== 'left') {
            snake.dx = grid;
            snake.dy = 0;
            snake.direction = 'right';
          }
          break;
        case 'ArrowDown':
          if (snake.direction !== 'up') {
            snake.dy = grid;
            snake.dx = 0;
            snake.direction = 'down';
          }
          break;
      }
    });

    // 9. Touch Controls: Handle Swipes with Prevention of Reverse
    canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
    canvas.addEventListener('touchmove', handleTouchMove, { passive: false });

    let xDown = null;
    let yDown = null;

    function getTouches(evt) {
      return evt.touches;
    }

    function handleTouchStart(evt) {
        const firstTouch = getTouches(evt)[0];
        xDown = firstTouch.clientX;
        yDown = firstTouch.clientY;
        evt.preventDefault(); // Prevent the default behavior
    }

    function handleTouchMove(evt) {
        if (!xDown || !yDown) {
            return;
        }

        const xUp = evt.touches[0].clientX;
        const yUp = evt.touches[0].clientY;

        const xDiff = xDown - xUp;
        const yDiff = yDown - yUp;

        if (Math.abs(xDiff) > Math.abs(yDiff)) { 
            if (xDiff > 0 && snake.direction !== 'right') {
                // Left swipe
                snake.dx = -grid;
                snake.dy = 0;
                snake.direction = 'left';
            } else if (xDiff < 0 && snake.direction !== 'left') {
                // Right swipe
                snake.dx = grid;
                snake.dy = 0;
                snake.direction = 'right';
            }
        } else {
            if (yDiff > 0 && snake.direction !== 'down') {
                // Up swipe
                snake.dy = -grid;
                snake.dx = 0;
                snake.direction = 'up';
            } else if (yDiff < 0 && snake.direction !== 'up') {
                // Down swipe
                snake.dy = grid;
                snake.dx = 0;
                snake.direction = 'down';
            }
        }

        evt.preventDefault(); // Prevent default scrolling
        xDown = null;
        yDown = null;
    }

    // 10. Helper Functions for Game Management
    function updateScore() {
      const scoreElement = document.querySelector('.score');
      const highScoreElement = document.querySelector('.high-score');
      scoreElement.textContent = `Score: ${score}`;
      highScoreElement.textContent = `High Score: ${highScore}`;
    }

    function placeApple() {
      apple.x = getRandomInt(0, canvasWidth / grid) * grid;
      apple.y = getRandomInt(0, canvasHeight / grid) * grid;

      // Ensure apple doesn't appear on the snake
      for (let cell of snake.cells) {
        if (cell.x === apple.x && cell.y === apple.y) {
          placeApple();
          break;
        }
      }
    }

    function resetGame() {
      snake.x = Math.floor(canvasWidth / 2 / grid) * grid;
      snake.y = Math.floor(canvasHeight / 2 / grid) * grid;
      snake.cells = [];
      snake.maxCells = 4;
      snake.dx = grid;
      snake.dy = 0;
      snake.direction = 'right';
      score = 0;
      updateScore();
      placeApple();
    }

    function endGame() {
      cancelAnimationFrame(animationFrameId);
      document.getElementById('gameOverScreen').style.display = 'block';
      document.getElementById('finalScore').textContent = score;
      document.getElementById('finalHighScore').textContent = highScore;

      if (score > highScore) {
        highScore = score;
        localStorage.setItem('snakeHighScore', highScore);
        document.querySelector('.high-score').textContent = `High Score: ${highScore}`;
        document.getElementById('finalHighScore').textContent = highScore;
      }
    }

    // 11. Start and Restart Game Controls
    const startScreen = document.getElementById('startScreen');
    const startButton = document.getElementById('startButton');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const restartButton = document.getElementById('restartButton');
    const resetHighScoreButton = document.getElementById('resetHighScoreButton');

    startButton.addEventListener('click', () => {
      startScreen.style.display = 'none';
      resetGame();
      requestAnimationFrame(loop);
    });

    restartButton.addEventListener('click', () => {
      gameOverScreen.style.display = 'none';
      resetGame();
      requestAnimationFrame(loop);
    });

    resetHighScoreButton.addEventListener('click', () => {
      highScore = 0;
      localStorage.setItem('snakeHighScore', highScore);
      updateScore();
      document.getElementById('gameOverScreen').querySelector('#finalHighScore').textContent = highScore;
    });

    // 12. Initialize Responsive Canvas and Event Listeners
    window.addEventListener('resize', () => {
      // Cancel the current game loop before resizing
      cancelAnimationFrame(animationFrameId);
      resizeCanvas();
    });

    // Initial canvas setup
    resizeCanvas();
  </script>
</body>
</html>
